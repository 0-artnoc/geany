A patch to Scintilla 1.77 containing our changes to Scintilla.
These are mainly commentation character changes(// vs /* */), the column mode editing patch,
LexOMS.cxx, a fix for LexPascal.cxx (r998) and a change for the Properties lexer (r1629).
diff -Naurp /tmp/sci/Editor.cxx scintilla/Editor.cxx
--- /tmp/sci/Editor.cxx	2008-09-04 16:05:55.000000000 +0200
+++ scintilla/Editor.cxx	2008-11-20 00:38:29.000000000 +0100
@@ -3379,22 +3379,51 @@ void Editor::AddChar(char ch) {
 // AddCharUTF inserts an array of bytes which may or may not be in UTF-8.
 void Editor::AddCharUTF(char *s, unsigned int len, bool treatAsDBCS) {
 	bool wasSelection = currentPos != anchor;
-	ClearSelection();
-	bool charReplaceAction = false;
-	if (inOverstrike && !wasSelection && !RangeContainsProtected(currentPos, currentPos + 1)) {
-		if (currentPos < (pdoc->Length())) {
-			if (!IsEOLChar(pdoc->CharAt(currentPos))) {
-				charReplaceAction = true;
-				pdoc->BeginUndoAction();
-				pdoc->DelChar(currentPos);
+    if(wasSelection && selType == selRectangle ) {
+        int startPos;
+        int endPos;
+
+        int c1 = pdoc->GetColumn(currentPos);
+        int c2 = pdoc->GetColumn(anchor);
+        int offset = c1 < c2 ? c1 : c2;
+
+        pdoc->BeginUndoAction();
+        SelectionLineIterator lineIterator(this, false);
+        while (lineIterator.Iterate()) {
+            startPos = lineIterator.startPos;
+            endPos   = lineIterator.endPos;
+
+            if(pdoc->GetColumn(endPos) >= offset){
+                unsigned int chars = endPos - startPos;
+                if (0 != chars) {
+                    pdoc->DeleteChars(startPos, chars);
+                }
+                pdoc->InsertString(startPos, s, len);
+            }
+        }
+        anchor += len;
+        currentPos += len;
+        SetRectangularRange();
+        pdoc->EndUndoAction();
+
+    } else {
+		ClearSelection();
+		bool charReplaceAction = false;
+		if (inOverstrike && !wasSelection && !RangeContainsProtected(currentPos, currentPos + 1)) {
+			if (currentPos < (pdoc->Length())) {
+				if (!IsEOLChar(pdoc->CharAt(currentPos))) {
+					charReplaceAction = true;
+					pdoc->BeginUndoAction();
+					pdoc->DelChar(currentPos);
+				}
 			}
 		}
-	}
-	if (pdoc->InsertString(currentPos, s, len)) {
-		SetEmptySelection(currentPos + len);
-	}
-	if (charReplaceAction) {
-		pdoc->EndUndoAction();
+		if (pdoc->InsertString(currentPos, s, len)) {
+			SetEmptySelection(currentPos + len);
+		}
+		if (charReplaceAction) {
+			pdoc->EndUndoAction();
+		}
 	}
 	// If in wrap mode rewrap current line so EnsureCaretVisible has accurate information
 	if (wrapState != eWrapNone) {
@@ -3566,14 +3595,41 @@ bool Editor::CanPaste() {
 }

 void Editor::Clear() {
-	if (currentPos == anchor) {
+    bool wasSelection = currentPos != anchor;
+    if(wasSelection && selType == selRectangle ) {
+        int startPos;
+        int endPos;
+
+        int c1 = pdoc->GetColumn(currentPos);
+        int c2 = pdoc->GetColumn(anchor);
+        int offset = c1 < c2 ? c1 : c2;
+
+        pdoc->BeginUndoAction();
+        SelectionLineIterator lineIterator(this, false);
+        while (lineIterator.Iterate()) {
+            startPos = lineIterator.startPos;
+            endPos   = lineIterator.endPos;
+
+            if(pdoc->GetColumn(endPos) >= offset){
+                unsigned int chars = endPos - startPos;
+                if (0 != chars) {
+                    pdoc->DeleteChars(startPos, chars);
+                } else
+		    pdoc->DelChar(startPos);
+            }
+        }
+        SetRectangularRange();
+        pdoc->EndUndoAction();
+
+    } else if (currentPos == anchor) {
 		if (!RangeContainsProtected(currentPos, currentPos + 1)) {
 			DelChar();
 		}
 	} else {
 		ClearSelection();
 	}
-	SetEmptySelection(currentPos);
+	if( !wasSelection )
+	    SetEmptySelection(currentPos);
 }

 void Editor::SelectAll() {
@@ -3609,7 +3665,33 @@ void Editor::DelChar() {
 }

 void Editor::DelCharBack(bool allowLineStartDeletion) {
-	if (currentPos == anchor) {
+	bool wasSelection = currentPos != anchor;
+    if(wasSelection && selType == selRectangle ) {
+        int startPos;
+        int endPos;
+
+        int c1 = pdoc->GetColumn(currentPos);
+        int c2 = pdoc->GetColumn(anchor);
+        int offset = c1 < c2 ? c1 : c2;
+
+        pdoc->BeginUndoAction();
+        SelectionLineIterator lineIterator(this, false);
+        while (lineIterator.Iterate()) {
+            startPos = lineIterator.startPos;
+            endPos   = lineIterator.endPos;
+
+            if(pdoc->GetColumn(endPos) >= offset){
+                unsigned int chars = endPos - startPos;
+                if (0 != chars) {
+                    pdoc->DeleteChars(startPos, chars);
+                } else
+		    pdoc->DelCharBack(startPos);
+            }
+        }
+        SetRectangularRange();
+        pdoc->EndUndoAction();
+
+    } else 	if (currentPos == anchor) {
 		if (!RangeContainsProtected(currentPos - 1, currentPos)) {
 			int lineCurrentPos = pdoc->LineFromPosition(currentPos);
 			if (allowLineStartDeletion || (pdoc->LineStart(lineCurrentPos) != currentPos)) {
diff -Naurp /tmp/sci/include/Accessor.h scintilla/include/Accessor.h
--- /tmp/sci/include/Accessor.h	2007-04-07 02:57:02.000000000 +0200
+++ scintilla/include/Accessor.h	2008-03-25 17:46:42.000000000 +0100
@@ -1,9 +1,9 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file Accessor.h
  ** Rapid easy access to contents of a Scintilla.
  **/
-// Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 enum { wsSpace = 1, wsTab = 2, wsSpaceTab = 4, wsInconsistent=8};

@@ -25,7 +25,7 @@ protected:
 	char buf[bufferSize+1];
 	int startPos;
 	int endPos;
-	int codePage;
+	int codePage;

 	virtual bool InternalIsLeadByte(char ch)=0;
 	virtual void Fill(int position)=0;
@@ -44,7 +44,7 @@ public:
 		if (position < startPos || position >= endPos) {
 			Fill(position);
 			if (position < startPos || position >= endPos) {
-				// Position is outside range of document
+				/* Position is outside range of document  */
 				return chDefault;
 			}
 		}
@@ -67,7 +67,7 @@ public:
 	virtual int GetPropertyInt(const char *key, int defaultValue=0)=0;
 	virtual char *GetProperties()=0;

-	// Style setting
+	/* Style setting */
 	virtual void StartAt(unsigned int start, char chMask=31)=0;
 	virtual void SetFlags(char chFlags_, char chWhile_)=0;
 	virtual unsigned int GetStartSegment()=0;
diff -Naurp /tmp/sci/include/KeyWords.h scintilla/include/KeyWords.h
--- /tmp/sci/include/KeyWords.h	2007-06-01 03:57:21.000000000 +0200
+++ scintilla/include/KeyWords.h	2008-03-25 17:46:24.000000000 +0100
@@ -1,9 +1,9 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file KeyWords.h
  ** Colourise for particular languages.
  **/
-// Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 #ifdef SCI_NAMESPACE
 namespace Scintilla {
@@ -11,7 +11,7 @@ namespace Scintilla {

 typedef void (*LexerFunction)(unsigned int startPos, int lengthDoc, int initStyle,
                   WordList *keywordlists[], Accessor &styler);
-
+
 /**
  * A LexerModule is responsible for lexing and folding a particular language.
  * The class maintains a list of LexerModules which can be searched to find a
@@ -31,9 +31,9 @@ protected:

 public:
 	const char *languageName;
-	LexerModule(int language_,
-		LexerFunction fnLexer_,
-		const char *languageName_=0,
+	LexerModule(int language_,
+		LexerFunction fnLexer_,
+		const char *languageName_=0,
 		LexerFunction fnFolder_=0,
 		const char * const wordListDescriptions_[] = NULL,
 		int styleBits_=5);
@@ -41,7 +41,7 @@ public:
 	}
 	int GetLanguage() const { return language; }

-	// -1 is returned if no WordList information is available
+	/* -1 is returned if no WordList information is available */
 	int GetNumWordLists() const;
 	const char *GetWordListDescription(int index) const;

@@ -78,7 +78,7 @@ inline bool iswordstart(char ch) {
 inline bool isoperator(char ch) {
 	if (isascii(ch) && isalnum(ch))
 		return false;
-	// '.' left out as it is used to make up numbers
+	/* '.' left out as it is used to make up numbers */
 	if (ch == '%' || ch == '^' || ch == '&' || ch == '*' ||
 	        ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
 	        ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
diff -Naurp /tmp/sci/include/Platform.h scintilla/include/Platform.h
--- /tmp/sci/include/Platform.h	2008-02-06 21:58:35.000000000 +0100
+++ scintilla/include/Platform.h	2008-03-25 17:46:03.000000000 +0100
@@ -1,18 +1,18 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file Platform.h
  ** Interface to platform facilities. Also includes some basic utilities.
  ** Implemented in PlatGTK.cxx for GTK+/Linux, PlatWin.cxx for Windows, and PlatWX.cxx for wxWindows.
  **/
-// Copyright 1998-2003 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2003 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 #ifndef PLATFORM_H
 #define PLATFORM_H

-// PLAT_GTK = GTK+ on Linux or Win32
-// PLAT_GTK_WIN32 is defined additionally when running PLAT_GTK under Win32
-// PLAT_WIN = Win32 API on Win32 OS
-// PLAT_WX is wxWindows on any supported platform
+/* PLAT_GTK = GTK+ on Linux or Win32
+ * PLAT_GTK_WIN32 is defined additionally when running PLAT_GTK under Win32
+ * PLAT_WIN = Win32 API on Win32 OS
+ * PLAT_WX is wxWindows on any supported platform */

 #define PLAT_GTK 0
 #define PLAT_GTK_WIN32 0
@@ -52,8 +52,8 @@
 namespace Scintilla {
 #endif

-// Underlying the implementation of the platform classes are platform specific types.
-// Sometimes these need to be passed around by client code so they are defined here
+/* Underlying the implementation of the platform classes are platform specific types.
+ * Sometimes these need to be passed around by client code so they are defined here */

 typedef void *FontID;
 typedef void *SurfaceID;
@@ -75,7 +75,7 @@ public:
 	explicit Point(int x_=0, int y_=0) : x(x_), y(y_) {
 	}

-	// Other automatically defined methods (assignment, copy constructor, destructor) are fine
+	/* Other automatically defined methods (assignment, copy constructor, destructor) are fine */

 	static Point FromLong(long lpoint);
 };
@@ -96,7 +96,7 @@ public:
 		left(left_), top(top_), right(right_), bottom(bottom_) {
 	}

-	// Other automatically defined methods (assignment, copy constructor, destructor) are fine
+	/* Other automatically defined methods (assignment, copy constructor, destructor) are fine */

 	bool operator==(PRectangle &rc) {
 		return (rc.left == left) && (rc.right == right) &&
@@ -240,7 +240,7 @@ struct ColourPair {
 	}
 };

-class Window;	// Forward declaration for Palette
+class Window;	/* Forward declaration for Palette */

 /**
  * Colour palette management.
@@ -250,10 +250,10 @@ class Palette {
 	int size;
 	ColourPair *entries;
 #if PLAT_GTK
-	void *allocatedPalette; // GdkColor *
+	void *allocatedPalette; /* GdkColor * */
 	int allocatedLen;
 #endif
-	// Private so Palette objects can not be copied
+	/* Private so Palette objects can not be copied */
 	Palette(const Palette &) {}
 	Palette &operator=(const Palette &) { return *this; }
 public:
@@ -286,7 +286,7 @@ protected:
 #if PLAT_WX
 	int ascent;
 #endif
-	// Private so Font objects can not be copied
+	/* Private so Font objects can not be copied */
 	Font(const Font &) {}
 	Font &operator=(const Font &) { id=0; return *this; }
 public:
@@ -298,7 +298,7 @@ public:
 	virtual void Release();

 	FontID GetID() { return id; }
-	// Alias another font - caller guarantees not to Release
+	/* Alias another font - caller guarantees not to Release */
 	void SetID(FontID id_) { id = id_; }
 	friend class Surface;
         friend class SurfaceImpl;
@@ -309,7 +309,7 @@ public:
  */
 class Surface {
 private:
-	// Private so Surface objects can not be copied
+	/* Private so Surface objects can not be copied */
 	Surface(const Surface &) {}
 	Surface &operator=(const Surface &) { return *this; }
 public:
@@ -475,13 +475,13 @@ class DynamicLibrary {
 public:
 	virtual ~DynamicLibrary() {};

-	/// @return Pointer to function "name", or NULL on failure.
+	/** @return Pointer to function "name", or NULL on failure. */
 	virtual Function FindFunction(const char *name) = 0;

-	/// @return true if the library was loaded successfully.
+	/** @return true if the library was loaded successfully. */
 	virtual bool IsValid() = 0;

-	/// @return An instance of a DynamicLibrary subclass with "modulePath" loaded.
+	/** @return An instance of a DynamicLibrary subclass with "modulePath" loaded. */
 	static DynamicLibrary *Load(const char *modulePath);
 };

@@ -490,12 +490,12 @@ public:
  * and chrome colour. Not a creatable object, more of a module with several functions.
  */
 class Platform {
-	// Private so Platform objects can not be copied
+	/* Private so Platform objects can not be copied */
 	Platform(const Platform &) {}
 	Platform &operator=(const Platform &) { return *this; }
 public:
-	// Should be private because no new Platforms are ever created
-	// but gcc warns about this
+	/* Should be private because no new Platforms are ever created
+	 * but gcc warns about this */
 	Platform() {}
 	~Platform() {}
 	static ColourDesired Chrome();
@@ -514,10 +514,10 @@ public:
 	static int DBCSCharLength(int codePage, const char *s);
 	static int DBCSCharMaxLength();

-	// These are utility functions not really tied to a platform
+	/* These are utility functions not really tied to a platform */
 	static int Minimum(int a, int b);
 	static int Maximum(int a, int b);
-	// Next three assume 16 bit shorts and 32 bit longs
+	/* Next three assume 16 bit shorts and 32 bit longs */
 	static long LongFromTwoShorts(short a,short b) {
 		return (a) | ((b) << 16);
 	}
@@ -547,7 +547,7 @@ public:
 }
 #endif

-// Shut up annoying Visual C++ warnings:
+/* Shut up annoying Visual C++ warnings: */
 #ifdef _MSC_VER
 #pragma warning(disable: 4244 4309 4514 4710)
 #endif
diff -Naurp /tmp/sci/include/PropSet.h scintilla/include/PropSet.h
--- /tmp/sci/include/PropSet.h	2007-07-24 11:14:06.000000000 +0200
+++ scintilla/include/PropSet.h	2008-03-25 17:48:33.000000000 +0100
@@ -1,9 +1,9 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file PropSet.h
  ** A Java style properties file module.
  **/
-// Copyright 1998-2002 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2002 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 #ifndef PROPSET_H
 #define PROPSET_H
@@ -56,10 +56,10 @@ public:
 	SString Expand(const char *withVars, int maxExpands=100) const;
 	int GetInt(const char *key, int defaultValue=0) const;
 	void Clear();
-	char *ToString() const;	// Caller must delete[] the return value
+	char *ToString() const;	/* Caller must delete[] the return value */

 private:
-	// copy-value semantics not implemented
+	/* copy-value semantics not implemented */
 	PropSet(const PropSet &copy);
 	void operator=(const PropSet &assign);
 };
@@ -68,11 +68,11 @@ private:
  */
 class WordList {
 public:
-	// Each word contains at least one character - a empty word acts as sentinel at the end.
+	/* Each word contains at least one character - a empty word acts as sentinel at the end. */
 	char **words;
 	char *list;
 	int len;
-	bool onlyLineEnds;	///< Delimited by any white space or only line ends
+	bool onlyLineEnds;	/**< Delimited by any white space or only line ends */
 	bool sorted;
 	int starts[256];
 	WordList(bool onlyLineEnds_ = false) :
@@ -96,8 +96,8 @@ inline bool IsAlphabetic(unsigned int ch
 #endif

 #ifdef _MSC_VER
-// Visual C++ doesn't like the private copy idiom for disabling
-// the default copy constructor and operator=, but it's fine.
+/* Visual C++ doesn't like the private copy idiom for disabling
+ * the default copy constructor and operator=, but it's fine. */
 #pragma warning(disable: 4511 4512)
 #endif

diff -Naurp /tmp/sci/include/SciLexer.h scintilla/include/SciLexer.h
--- /tmp/sci/include/SciLexer.h	2008-10-09 04:46:57.000000000 +0200
+++ scintilla/include/SciLexer.h	2008-10-18 15:02:28.000000000 +0200
@@ -1,19 +1,19 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file SciLexer.h
  ** Interface to the added lexer functions in the SciLexer version of the edit control.
  **/
-// Copyright 1998-2002 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2002 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

-// Most of this file is automatically generated from the Scintilla.iface interface definition
-// file which contains any comments about the definitions. HFacer.py does the generation.
+/* Most of this file is automatically generated from the Scintilla.iface interface definition
+ * file which contains any comments about the definitions. HFacer.py does the generation. */

 #ifndef SCILEXER_H
 #define SCILEXER_H

-// SciLexer features - not in standard Scintilla
+/* SciLexer features - not in standard Scintilla */

-//++Autogenerated -- start of section automatically generated from Scintilla.iface
+/*++Autogenerated -- start of section automatically generated from Scintilla.iface*/
 #define SCLEX_CONTAINER 0
 #define SCLEX_NULL 1
 #define SCLEX_PYTHON 2
@@ -101,7 +101,7 @@
 #define SCLEX_R 86
 #define SCLEX_MAGIK 87
 #define SCLEX_POWERSHELL 88
-#define SCLEX_MYSQL 89
+#define SCLEX_OMS 89
 #define SCLEX_PO 90
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
@@ -1273,6 +1273,6 @@
 #define SCE_PO_FUZZY 8
 #define SCLEX_ASP 29
 #define SCLEX_PHP 30
-//--Autogenerated -- end of section automatically generated from Scintilla.iface
+/*--Autogenerated -- end of section automatically generated from Scintilla.iface*/

 #endif
diff -Naurp /tmp/sci/include/Scintilla.iface scintilla/include/Scintilla.iface
--- /tmp/sci/include/Scintilla.iface	2008-10-09 04:46:57.000000000 +0200
+++ scintilla/include/Scintilla.iface	2008-10-18 15:02:28.000000000 +0200
@@ -2007,7 +2007,7 @@ val SCLEX_ASYMPTOTE=85
 val SCLEX_R=86
 val SCLEX_MAGIK=87
 val SCLEX_POWERSHELL=88
-val SCLEX_MYSQL=89
+val SCLEX_OMS=89
 val SCLEX_PO=90

 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
diff -Naurp /tmp/sci/include/ScintillaWidget.h scintilla/include/ScintillaWidget.h
--- /tmp/sci/include/ScintillaWidget.h	2006-05-18 15:00:46.000000000 +0200
+++ scintilla/include/ScintillaWidget.h	2008-03-25 17:47:38.000000000 +0100
@@ -1,10 +1,10 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file ScintillaWidget.h
  ** Definition of Scintilla widget for GTK+.
  ** Only needed by GTK+ code but is harmless on other platforms.
  **/
-// Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 #ifndef SCINTILLAWIDGET_H
 #define SCINTILLAWIDGET_H
diff -Naurp /tmp/sci/include/SString.h scintilla/include/SString.h
--- /tmp/sci/include/SString.h	2007-06-01 03:57:21.000000000 +0200
+++ scintilla/include/SString.h	2008-03-25 17:47:30.000000000 +0100
@@ -1,15 +1,15 @@
-// SciTE - Scintilla based Text Editor
+/* SciTE - Scintilla based Text Editor */
 /** @file SString.h
  ** A simple string class.
  **/
-// Copyright 1998-2004 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2004 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 #ifndef SSTRING_H
 #define SSTRING_H


-// These functions are implemented because each platform calls them something different.
+/* These functions are implemented because each platform calls them something different. */
 int CompareCaseInsensitive(const char *a, const char *b);
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len);
 bool EqualCaseInsensitive(const char *a, const char *b);
@@ -18,9 +18,9 @@ bool EqualCaseInsensitive(const char *a,
 namespace Scintilla {
 #endif

-// Define another string class.
-// While it would be 'better' to use std::string, that doubles the executable size.
-// An SString may contain embedded nul characters.
+/* Define another string class.
+ * While it would be 'better' to use std::string, that doubles the executable size.
+ * An SString may contain embedded nul characters. */

 /**
  * Base class from which the two other classes (SBuffer & SString)
@@ -34,12 +34,12 @@ public:
 	enum { measure_length=0xffffffffU};

 protected:
-	char *s;				///< The C string
-	lenpos_t sSize;			///< The size of the buffer, less 1: ie. the maximum size of the string
+	char *s;				/**< The C string */
+	lenpos_t sSize;			/**< The size of the buffer, less 1: ie. the maximum size of the string */

 	SContainer() : s(0), sSize(0) {}
 	~SContainer() {
-		delete []s;	// Suppose it was allocated using StringAllocate
+		delete []s;	/* Suppose it was allocated using StringAllocate */
 		s = 0;
 		sSize = 0;
 	}
@@ -64,8 +64,8 @@ public:
 	 * @return the pointer to the new string
 	 */
 	static char *StringAllocate(
-		const char *s,			///< The string to duplicate
-		lenpos_t len=measure_length);	///< The length of memory to allocate. Optional.
+		const char *s,			/**< The string to duplicate */
+		lenpos_t len=measure_length);	/**< The length of memory to allocate. Optional. */
 };


@@ -92,14 +92,14 @@ public:
 		}
 	}
 private:
-	/// Copy constructor
-	// Here only to be on the safe size, user should avoid returning SBuffer values.
+	/** Copy constructor */
+	/* Here only to be on the safe size, user should avoid returning SBuffer values. */
 	SBuffer(const SBuffer &source) : SContainer() {
 		s = StringAllocate(source.s, source.sSize);
 		sSize = (s) ? source.sSize : 0;
 	}
-	/// Default assignment operator
-	// Same here, shouldn't be used
+	/** Default assignment operator */
+	/* Same here, shouldn't be used */
 	SBuffer &operator=(const SBuffer &source) {
 		if (this != &source) {
 			delete []s;
@@ -134,8 +134,8 @@ public:
  * functions to allow reliable manipulations of these strings, other than simple appends, etc.
  */
 class SString : protected SContainer {
-	lenpos_t sLen;			///< The size of the string in s
-	lenpos_t sizeGrowth;	///< Minimum growth size when appending strings
+	lenpos_t sLen;			/**< The size of the string in s */
+	lenpos_t sizeGrowth;	/**< Minimum growth size when appending strings */
 	enum { sizeGrowthDefault = 64 };

 	bool grow(lenpos_t lenNew);
@@ -154,11 +154,11 @@ public:
 	SString(SBuffer &buf) : sizeGrowth(sizeGrowthDefault) {
 		s = buf.ptr();
 		sSize = sLen = buf.size();
-		// Consumes the given buffer!
+		/* Consumes the given buffer! */
 		buf.reset();
 	}
 	SString(const char *s_, lenpos_t first, lenpos_t last) : sizeGrowth(sizeGrowthDefault) {
-		// note: expects the "last" argument to point one beyond the range end (a la STL iterators)
+		/* note: expects the "last" argument to point one beyond the range end (a la STL iterators) */
 		s = StringAllocate(s_ + first, last - first);
 		sSize = sLen = (s) ? last - first : 0;
 	}
@@ -246,7 +246,7 @@ public:
 	void remove(lenpos_t pos, lenpos_t len);

 	SString &change(lenpos_t pos, char ch) {
-		if (pos < sLen) {					// character changed must be in string bounds
+		if (pos < sLen) {					/* character changed must be in string bounds */
 			*(s + pos) = ch;
 		}
 		return *this;
@@ -276,8 +276,8 @@ public:
  * @return the pointer to the new string
  */
 inline char *StringDup(
-	const char *s,			///< The string to duplicate
-	SContainer::lenpos_t len=SContainer::measure_length)	///< The length of memory to allocate. Optional.
+	const char *s,			/**< The string to duplicate*/
+	SContainer::lenpos_t len=SContainer::measure_length)	/**< The length of memory to allocate. Optional.*/
 {
 	return SContainer::StringAllocate(s, len);
 }
diff -Naurp /tmp/sci/include/WindowAccessor.h scintilla/include/WindowAccessor.h
--- /tmp/sci/include/WindowAccessor.h	2007-06-01 03:57:21.000000000 +0200
+++ scintilla/include/WindowAccessor.h	2008-03-25 17:46:58.000000000 +0100
@@ -1,10 +1,10 @@
-// Scintilla source code edit control
+/* Scintilla source code edit control */
 /** @file WindowAccessor.h
  ** Implementation of BufferAccess and StylingAccess on a Scintilla
  ** rapid easy access to contents of a Scintilla.
  **/
-// Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
-// The License.txt file describes the conditions under which this software may be distributed.
+/* Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
+ * The License.txt file describes the conditions under which this software may be distributed. */

 #ifdef SCI_NAMESPACE
 namespace Scintilla {
@@ -13,7 +13,7 @@ namespace Scintilla {
 /**
  */
 class WindowAccessor : public Accessor {
-	// Private so WindowAccessor objects can not be copied
+	/* Private so WindowAccessor objects can not be copied */
 	WindowAccessor(const WindowAccessor &source) : Accessor(), props(source.props) {}
 	WindowAccessor &operator=(const WindowAccessor &) { return *this; }
 protected:
@@ -30,8 +30,8 @@ protected:
 	bool InternalIsLeadByte(char ch);
 	void Fill(int position);
 public:
-	WindowAccessor(WindowID id_, PropSet &props_) :
-		Accessor(), id(id_), props(props_),
+	WindowAccessor(WindowID id_, PropSet &props_) :
+		Accessor(), id(id_), props(props_),
 		lenDoc(-1), validLen(0), chFlags(0), chWhile(0) {
 	}
 	~WindowAccessor();
@@ -44,8 +44,8 @@ public:
 	void Flush();
 	int GetLineState(int line);
 	int SetLineState(int line, int state);
-	int GetPropertyInt(const char *key, int defaultValue=0) {
-		return props.GetInt(key, defaultValue);
+	int GetPropertyInt(const char *key, int defaultValue=0) {
+		return props.GetInt(key, defaultValue);
 	}
 	char *GetProperties() {
 		return props.ToString();
diff -Naurp /tmp/sci/KeyWords.cxx scintilla/KeyWords.cxx
--- /tmp/sci/KeyWords.cxx	2008-10-08 13:24:19.000000000 +0200
+++ scintilla/KeyWords.cxx	2008-11-29 13:53:57.000000000 +0100
@@ -141,92 +141,33 @@ int Scintilla_LinkLexers() {

 //++Autogenerated -- run src/LexGen.py to regenerate
 //**\(\tLINK_LEXER(\*);\n\)
-	LINK_LEXER(lmAbaqus);
-	LINK_LEXER(lmAda);
-	LINK_LEXER(lmAns1);
-	LINK_LEXER(lmAPDL);
 	LINK_LEXER(lmAsm);
-	LINK_LEXER(lmASP);
-	LINK_LEXER(lmASY);
-	LINK_LEXER(lmAU3);
-	LINK_LEXER(lmAVE);
-	LINK_LEXER(lmBaan);
 	LINK_LEXER(lmBash);
-	LINK_LEXER(lmBatch);
-	LINK_LEXER(lmBlitzBasic);
-	LINK_LEXER(lmBullant);
+	LINK_LEXER(lmFreeBasic);
 	LINK_LEXER(lmCaml);
-	LINK_LEXER(lmClw);
-	LINK_LEXER(lmClwNoCase);
-	LINK_LEXER(lmCmake);
-	LINK_LEXER(lmConf);
 	LINK_LEXER(lmCPP);
-	LINK_LEXER(lmCPPNoCase);
-	LINK_LEXER(lmCsound);
 	LINK_LEXER(lmCss);
 	LINK_LEXER(lmD);
 	LINK_LEXER(lmDiff);
-	LINK_LEXER(lmEiffel);
-	LINK_LEXER(lmEiffelkw);
-	LINK_LEXER(lmErlang);
-	LINK_LEXER(lmErrorList);
-	LINK_LEXER(lmESCRIPT);
 	LINK_LEXER(lmF77);
-	LINK_LEXER(lmFlagShip);
-	LINK_LEXER(lmForth);
 	LINK_LEXER(lmFortran);
-	LINK_LEXER(lmFreeBasic);
-	LINK_LEXER(lmGAP);
-	LINK_LEXER(lmGui4Cli);
 	LINK_LEXER(lmHaskell);
 	LINK_LEXER(lmHTML);
-	LINK_LEXER(lmInno);
-	LINK_LEXER(lmKix);
 	LINK_LEXER(lmLatex);
-	LINK_LEXER(lmLISP);
-	LINK_LEXER(lmLot);
-	LINK_LEXER(lmLout);
 	LINK_LEXER(lmLua);
-	LINK_LEXER(lmMagikSF);
 	LINK_LEXER(lmMake);
 	LINK_LEXER(lmMatlab);
-	LINK_LEXER(lmMETAPOST);
-	LINK_LEXER(lmMMIXAL);
-	LINK_LEXER(lmMSSQL);
-	LINK_LEXER(lmMySQL);
-	LINK_LEXER(lmNncrontab);
-	LINK_LEXER(lmNsis);
 	LINK_LEXER(lmNull);
-	LINK_LEXER(lmOctave);
-	LINK_LEXER(lmOpal);
+	LINK_LEXER(lmOMS);
 	LINK_LEXER(lmPascal);
-	LINK_LEXER(lmPB);
 	LINK_LEXER(lmPerl);
-	LINK_LEXER(lmPHP);
-	LINK_LEXER(lmPHPSCRIPT);
-	LINK_LEXER(lmPLM);
 	LINK_LEXER(lmPo);
-	LINK_LEXER(lmPOV);
-	LINK_LEXER(lmPowerShell);
-	LINK_LEXER(lmProgress);
 	LINK_LEXER(lmProps);
-	LINK_LEXER(lmPS);
-	LINK_LEXER(lmPureBasic);
 	LINK_LEXER(lmPython);
 	LINK_LEXER(lmR);
-	LINK_LEXER(lmREBOL);
 	LINK_LEXER(lmRuby);
-	LINK_LEXER(lmScriptol);
-	LINK_LEXER(lmSmalltalk);
-	LINK_LEXER(lmSpecman);
-	LINK_LEXER(lmSpice);
 	LINK_LEXER(lmSQL);
-	LINK_LEXER(lmTADS3);
 	LINK_LEXER(lmTCL);
-	LINK_LEXER(lmTeX);
-	LINK_LEXER(lmVB);
-	LINK_LEXER(lmVBScript);
-	LINK_LEXER(lmVerilog);
 	LINK_LEXER(lmVHDL);
 	LINK_LEXER(lmXML);
 	LINK_LEXER(lmYAML);
diff -Naurp /tmp/sci/LexOMS.cxx scintilla/LexOMS.cxx
--- /tmp/sci/LexOMS.cxx	1970-01-01 01:00:00.000000000 +0100
+++ scintilla/LexOMS.cxx	2006-05-05 17:44:00.000000000 +0200
@@ -0,0 +1,663 @@
+// Scintilla source code edit control
+/** @file LexBash.cxx
+ ** Lexer for Bash.
+ **/
+// Copyright 2004-2005 by Neil Hodgson <neilh@scintilla.org>
+// Adapted from LexPerl by Kein-Hong Man <mkh@pl.jaring.my> 2004
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Platform.h"
+
+#include "PropSet.h"
+#include "Accessor.h"
+#include "KeyWords.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#define BASH_BASE_ERROR		65
+#define BASH_BASE_DECIMAL	66
+#define BASH_BASE_HEX		67
+#define BASH_BASE_OCTAL		68
+#define BASH_BASE_OCTAL_ERROR	69
+
+#define HERE_DELIM_MAX 256
+
+static inline int translateBashDigit(char ch) {
+	if (ch >= '0' && ch <= '9') {
+		return ch - '0';
+	} else if (ch >= 'a' && ch <= 'z') {
+		return ch - 'a' + 10;
+	} else if (ch >= 'A' && ch <= 'Z') {
+		return ch - 'A' + 36;
+	} else if (ch == '@') {
+		return 62;
+	} else if (ch == '_') {
+		return 63;
+	}
+	return BASH_BASE_ERROR;
+}
+
+static inline bool isEOLChar(char ch) {
+	return (ch == '\r') || (ch == '\n');
+}
+
+static bool isSingleCharOp(char ch) {
+	char strCharSet[2];
+	strCharSet[0] = ch;
+	strCharSet[1] = '\0';
+	return (NULL != strstr("rwxoRWXOezsfdlpSbctugkTBMACahGLNn", strCharSet));
+}
+
+static inline bool isBashOperator(char ch) {
+	if (ch == '^' || ch == '&' || ch == '\\' || ch == '%' ||
+	        ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
+	        ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
+	        ch == '[' || ch == ']' || ch == ':' || ch == ';' ||
+	        ch == '>' || ch == ',' || ch == '/' || ch == '<' ||
+	        ch == '?' || ch == '!' || ch == '.' || ch == '~' ||
+		ch == '@')
+		return true;
+	return false;
+}
+
+static int classifyWordBash(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler) {
+	char s[100];
+	for (unsigned int i = 0; i < end - start + 1 && i < 30; i++) {
+		s[i] = styler[start + i];
+		s[i + 1] = '\0';
+	}
+	char chAttr = SCE_SH_IDENTIFIER;
+	if (keywords.InList(s))
+		chAttr = SCE_SH_WORD;
+	styler.ColourTo(end, chAttr);
+	return chAttr;
+}
+
+static inline int getBashNumberBase(unsigned int start, unsigned int end, Accessor &styler) {
+	int base = 0;
+	for (unsigned int i = 0; i < end - start + 1 && i < 10; i++) {
+		base = base * 10 + (styler[start + i] - '0');
+	}
+	if (base > 64 || (end - start) > 1) {
+		return BASH_BASE_ERROR;
+	}
+	return base;
+}
+
+static inline bool isEndVar(char ch) {
+	return !isalnum(ch) && ch != '$' && ch != '_';
+}
+
+static inline bool isNonQuote(char ch) {
+	return isalnum(ch) || ch == '_';
+}
+
+static bool isMatch(Accessor &styler, int lengthDoc, int pos, const char *val) {
+	if ((pos + static_cast<int>(strlen(val))) >= lengthDoc) {
+		return false;
+	}
+	while (*val) {
+		if (*val != styler[pos++]) {
+			return false;
+		}
+		val++;
+	}
+	return true;
+}
+
+static char opposite(char ch) {
+	if (ch == '(')
+		return ')';
+	if (ch == '[')
+		return ']';
+	if (ch == '{')
+		return '}';
+	if (ch == '<')
+		return '>';
+	return ch;
+}
+
+static void ColouriseBashDoc(unsigned int startPos, int length, int initStyle,
+                             WordList *keywordlists[], Accessor &styler) {
+
+	// Lexer for bash often has to backtrack to start of current style to determine
+	// which characters are being used as quotes, how deeply nested is the
+	// start position and what the termination string is for here documents
+
+	WordList &keywords = *keywordlists[0];
+
+	class HereDocCls {
+	public:
+		int State;		// 0: '<<' encountered
+		// 1: collect the delimiter
+		// 2: here doc text (lines after the delimiter)
+		char Quote;		// the char after '<<'
+		bool Quoted;		// true if Quote in ('\'','"','`')
+		bool Indent;		// indented delimiter (for <<-)
+		int DelimiterLength;	// strlen(Delimiter)
+		char *Delimiter;	// the Delimiter, 256: sizeof PL_tokenbuf
+		HereDocCls() {
+			State = 0;
+            Quote = 0;
+            Quoted = false;
+            Indent = 0;
+			DelimiterLength = 0;
+			Delimiter = new char[HERE_DELIM_MAX];
+			Delimiter[0] = '\0';
+		}
+		~HereDocCls() {
+			delete []Delimiter;
+		}
+	};
+	HereDocCls HereDoc;
+
+	class QuoteCls {
+		public:
+		int  Rep;
+		int  Count;
+		char Up;
+		char Down;
+		QuoteCls() {
+			this->New(1);
+		}
+		void New(int r) {
+			Rep   = r;
+			Count = 0;
+			Up    = '\0';
+			Down  = '\0';
+		}
+		void Open(char u) {
+			Count++;
+			Up    = u;
+			Down  = opposite(Up);
+		}
+	};
+	QuoteCls Quote;
+
+	int state = initStyle;
+	int numBase = 0;
+	unsigned int lengthDoc = startPos + length;
+
+	// If in a long distance lexical state, seek to the beginning to find quote characters
+	// Bash strings can be multi-line with embedded newlines, so backtrack.
+	// Bash numbers have additional state during lexing, so backtrack too.
+	if (state == SCE_SH_HERE_Q) {
+		while ((startPos > 1) && (styler.StyleAt(startPos) != SCE_SH_HERE_DELIM)) {
+			startPos--;
+		}
+		startPos = styler.LineStart(styler.GetLine(startPos));
+		state = styler.StyleAt(startPos - 1);
+	}
+	if (state == SCE_SH_STRING
+	 || state == SCE_SH_BACKTICKS
+	 || state == SCE_SH_CHARACTER
+	 || state == SCE_SH_NUMBER
+	 || state == SCE_SH_IDENTIFIER
+	 || state == SCE_SH_COMMENTLINE
+	) {
+		while ((startPos > 1) && (styler.StyleAt(startPos - 1) == state)) {
+			startPos--;
+		}
+		state = SCE_SH_DEFAULT;
+	}
+
+	styler.StartAt(startPos);
+	char chPrev = styler.SafeGetCharAt(startPos - 1);
+	if (startPos == 0)
+		chPrev = '\n';
+	char chNext = styler[startPos];
+	styler.StartSegment(startPos);
+
+	for (unsigned int i = startPos; i < lengthDoc; i++) {
+		char ch = chNext;
+		// if the current character is not consumed due to the completion of an
+		// earlier style, lexing can be restarted via a simple goto
+	restartLexer:
+		chNext = styler.SafeGetCharAt(i + 1);
+		char chNext2 = styler.SafeGetCharAt(i + 2);
+
+		if (styler.IsLeadByte(ch)) {
+			chNext = styler.SafeGetCharAt(i + 2);
+			chPrev = ' ';
+			i += 1;
+			continue;
+		}
+
+		if ((chPrev == '\r' && ch == '\n')) {	// skip on DOS/Windows
+			styler.ColourTo(i, state);
+			chPrev = ch;
+			continue;
+		}
+
+		if (HereDoc.State == 1 && isEOLChar(ch)) {
+			// Begin of here-doc (the line after the here-doc delimiter):
+			// Lexically, the here-doc starts from the next line after the >>, but the
+			// first line of here-doc seem to follow the style of the last EOL sequence
+			HereDoc.State = 2;
+			if (HereDoc.Quoted) {
+				if (state == SCE_SH_HERE_DELIM) {
+					// Missing quote at end of string! We are stricter than bash.
+					// Colour here-doc anyway while marking this bit as an error.
+					state = SCE_SH_ERROR;
+				}
+				styler.ColourTo(i - 1, state);
+				// HereDoc.Quote always == '\''
+				state = SCE_SH_HERE_Q;
+			} else {
+				styler.ColourTo(i - 1, state);
+				// always switch
+				state = SCE_SH_HERE_Q;
+			}
+		}
+
+		if (state == SCE_SH_DEFAULT) {
+			if (ch == '\\') {	// escaped character
+				i++;
+				ch = chNext;
+				chNext = chNext2;
+				styler.ColourTo(i, SCE_SH_IDENTIFIER);
+			} else if (isdigit(ch)) {
+				state = SCE_SH_NUMBER;
+				numBase = BASH_BASE_DECIMAL;
+				if (ch == '0') {	// hex,octal
+					if (chNext == 'x' || chNext == 'X') {
+						numBase = BASH_BASE_HEX;
+						i++;
+						ch = chNext;
+						chNext = chNext2;
+					} else if (isdigit(chNext)) {
+						numBase = BASH_BASE_OCTAL;
+					}
+				}
+			} else if (iswordstart(ch)) {
+				state = SCE_SH_WORD;
+				if (!iswordchar(chNext) && chNext != '+' && chNext != '-') {
+					// We need that if length of word == 1!
+					// This test is copied from the SCE_SH_WORD handler.
+					classifyWordBash(styler.GetStartSegment(), i, keywords, styler);
+					state = SCE_SH_DEFAULT;
+				}
+			} else if (ch == '#') {
+				state = SCE_SH_COMMENTLINE;
+			} else if (ch == '\"') {
+				state = SCE_SH_STRING;
+				Quote.New(1);
+				Quote.Open(ch);
+/*			} else if (ch == '\'') {
+				state = SCE_SH_CHARACTER;
+				Quote.New(1);
+				Quote.Open(ch);
+*/			} else if (ch == '`') {
+				state = SCE_SH_BACKTICKS;
+				Quote.New(1);
+				Quote.Open(ch);
+			} else if (ch == '$') {
+				if (chNext == '{') {
+					state = SCE_SH_PARAM;
+					goto startQuote;
+/*				} else if (chNext == '\'') {
+					state = SCE_SH_CHARACTER;
+					goto startQuote;
+*/				} else if (chNext == '"') {
+					state = SCE_SH_STRING;
+					goto startQuote;
+				} else if (chNext == '(' && chNext2 == '(') {
+					styler.ColourTo(i, SCE_SH_OPERATOR);
+					state = SCE_SH_DEFAULT;
+					goto skipChar;
+				} else if (chNext == '(' || chNext == '`') {
+					state = SCE_SH_BACKTICKS;
+				startQuote:
+					Quote.New(1);
+					Quote.Open(chNext);
+					goto skipChar;
+				} else {
+					state = SCE_SH_SCALAR;
+				skipChar:
+					i++;
+					ch = chNext;
+					chNext = chNext2;
+				}
+			} else if (ch == '*') {
+				if (chNext == '*') {	// exponentiation
+					i++;
+					ch = chNext;
+					chNext = chNext2;
+				}
+				styler.ColourTo(i, SCE_SH_OPERATOR);
+			} else if (ch == '<' && chNext == '<') {
+				state = SCE_SH_HERE_DELIM;
+				HereDoc.State = 0;
+				HereDoc.Indent = false;
+			} else if (ch == '-'	// file test operators
+			           && isSingleCharOp(chNext)
+			           && !isalnum((chNext2 = styler.SafeGetCharAt(i+2)))) {
+				styler.ColourTo(i + 1, SCE_SH_WORD);
+				state = SCE_SH_DEFAULT;
+				i++;
+				ch = chNext;
+				chNext = chNext2;
+			} else if (isBashOperator(ch)) {
+				styler.ColourTo(i, SCE_SH_OPERATOR);
+			} else {
+				// keep colouring defaults to make restart easier
+				styler.ColourTo(i, SCE_SH_DEFAULT);
+			}
+		} else if (state == SCE_SH_NUMBER) {
+			int digit = translateBashDigit(ch);
+			if (numBase == BASH_BASE_DECIMAL) {
+				if (ch == '#') {
+					numBase = getBashNumberBase(styler.GetStartSegment(), i - 1, styler);
+					if (numBase == BASH_BASE_ERROR)	// take the rest as comment
+						goto numAtEnd;
+				} else if (!isdigit(ch))
+					goto numAtEnd;
+			} else if (numBase == BASH_BASE_HEX) {
+				if ((digit < 16) || (digit >= 36 && digit <= 41)) {
+					// hex digit 0-9a-fA-F
+				} else
+					goto numAtEnd;
+			} else if (numBase == BASH_BASE_OCTAL ||
+				   numBase == BASH_BASE_OCTAL_ERROR) {
+				if (digit > 7) {
+					if (digit <= 9) {
+						numBase = BASH_BASE_OCTAL_ERROR;
+					} else
+						goto numAtEnd;
+				}
+			} else if (numBase == BASH_BASE_ERROR) {
+				if (digit > 9)
+					goto numAtEnd;
+			} else {	// DD#DDDD number style handling
+				if (digit != BASH_BASE_ERROR) {
+					if (numBase <= 36) {
+						// case-insensitive if base<=36
+						if (digit >= 36) digit -= 26;
+					}
+					if (digit >= numBase) {
+						if (digit <= 9) {
+							numBase = BASH_BASE_ERROR;
+						} else
+							goto numAtEnd;
+					}
+				} else {
+			numAtEnd:
+					if (numBase == BASH_BASE_ERROR ||
+					    numBase == BASH_BASE_OCTAL_ERROR)
+						state = SCE_SH_ERROR;
+					styler.ColourTo(i - 1, state);
+					state = SCE_SH_DEFAULT;
+					goto restartLexer;
+				}
+			}
+		} else if (state == SCE_SH_WORD) {
+			if (!iswordchar(chNext) && chNext != '+' && chNext != '-') {
+				// "." never used in Bash variable names
+				// but used in file names
+				classifyWordBash(styler.GetStartSegment(), i, keywords, styler);
+				state = SCE_SH_DEFAULT;
+				ch = ' ';
+			}
+		} else if (state == SCE_SH_IDENTIFIER) {
+			if (!iswordchar(chNext) && chNext != '+' && chNext != '-') {
+				styler.ColourTo(i, SCE_SH_IDENTIFIER);
+				state = SCE_SH_DEFAULT;
+				ch = ' ';
+			}
+		} else {
+			if (state == SCE_SH_COMMENTLINE) {
+				if (ch == '\\' && isEOLChar(chNext)) {
+					// comment continuation
+					if (chNext == '\r' && chNext2 == '\n') {
+						i += 2;
+						ch = styler.SafeGetCharAt(i);
+						chNext = styler.SafeGetCharAt(i + 1);
+					} else {
+						i++;
+						ch = chNext;
+						chNext = chNext2;
+					}
+				} else if (isEOLChar(ch)) {
+					styler.ColourTo(i - 1, state);
+					state = SCE_SH_DEFAULT;
+					goto restartLexer;
+				} else if (isEOLChar(chNext)) {
+					styler.ColourTo(i, state);
+					state = SCE_SH_DEFAULT;
+				}
+			} else if (state == SCE_SH_HERE_DELIM) {
+				//
+				// From Bash info:
+				// ---------------
+				// Specifier format is: <<[-]WORD
+				// Optional '-' is for removal of leading tabs from here-doc.
+				// Whitespace acceptable after <<[-] operator
+				//
+				if (HereDoc.State == 0) { // '<<' encountered
+					HereDoc.State = 1;
+					HereDoc.Quote = chNext;
+					HereDoc.Quoted = false;
+					HereDoc.DelimiterLength = 0;
+					HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+					//if (chNext == '\'' || chNext == '\"') {	// a quoted here-doc delimiter (' or ")
+					if (chNext == '\"') {	// a quoted here-doc delimiter (' or ")
+						i++;
+						ch = chNext;
+						chNext = chNext2;
+						HereDoc.Quoted = true;
+					} else if (!HereDoc.Indent && chNext == '-') {	// <<- indent case
+						HereDoc.Indent = true;
+						HereDoc.State = 0;
+					} else if (isalpha(chNext) || chNext == '_' || chNext == '\\'
+						|| chNext == '-' || chNext == '+' || chNext == '!') {
+						// an unquoted here-doc delimiter, no special handling
+                        // TODO check what exactly bash considers part of the delim
+					} else if (chNext == '<') {	// HERE string <<<
+						i++;
+						ch = chNext;
+						chNext = chNext2;
+						styler.ColourTo(i, SCE_SH_HERE_DELIM);
+						state = SCE_SH_DEFAULT;
+						HereDoc.State = 0;
+					} else if (isspacechar(chNext)) {
+						// eat whitespace
+						HereDoc.State = 0;
+					} else if (isdigit(chNext) || chNext == '=' || chNext == '$') {
+						// left shift << or <<= operator cases
+						styler.ColourTo(i, SCE_SH_OPERATOR);
+						state = SCE_SH_DEFAULT;
+						HereDoc.State = 0;
+					} else {
+						// symbols terminates; deprecated zero-length delimiter
+					}
+				} else if (HereDoc.State == 1) { // collect the delimiter
+					if (HereDoc.Quoted) { // a quoted here-doc delimiter
+						if (ch == HereDoc.Quote) { // closing quote => end of delimiter
+							styler.ColourTo(i, state);
+							state = SCE_SH_DEFAULT;
+						} else {
+							if (ch == '\\' && chNext == HereDoc.Quote) { // escaped quote
+								i++;
+								ch = chNext;
+								chNext = chNext2;
+							}
+							HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+							HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+						}
+					} else { // an unquoted here-doc delimiter
+						if (isalnum(ch) || ch == '_' || ch == '-' || ch == '+' || ch == '!') {
+							HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+							HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+						} else if (ch == '\\') {
+							// skip escape prefix
+						} else {
+							styler.ColourTo(i - 1, state);
+							state = SCE_SH_DEFAULT;
+							goto restartLexer;
+						}
+					}
+					if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {
+						styler.ColourTo(i - 1, state);
+						state = SCE_SH_ERROR;
+						goto restartLexer;
+					}
+				}
+			} else if (HereDoc.State == 2) {
+				// state == SCE_SH_HERE_Q
+				if (isMatch(styler, lengthDoc, i, HereDoc.Delimiter)) {
+					if (!HereDoc.Indent && isEOLChar(chPrev)) {
+					endHereDoc:
+						// standard HERE delimiter
+						i += HereDoc.DelimiterLength;
+						chPrev = styler.SafeGetCharAt(i - 1);
+						ch = styler.SafeGetCharAt(i);
+						if (isEOLChar(ch)) {
+							styler.ColourTo(i - 1, state);
+							state = SCE_SH_DEFAULT;
+							HereDoc.State = 0;
+							goto restartLexer;
+						}
+						chNext = styler.SafeGetCharAt(i + 1);
+					} else if (HereDoc.Indent) {
+						// indented HERE delimiter
+						unsigned int bk = (i > 0)? i - 1: 0;
+						while (i > 0) {
+							ch = styler.SafeGetCharAt(bk--);
+							if (isEOLChar(ch)) {
+								goto endHereDoc;
+							} else if (!isspacechar(ch)) {
+								break;	// got leading non-whitespace
+							}
+						}
+					}
+				}
+			} else if (state == SCE_SH_SCALAR) {	// variable names
+				if (isEndVar(ch)) {
+					if ((state == SCE_SH_SCALAR)
+					    && i == (styler.GetStartSegment() + 1)) {
+						// Special variable: $(, $_ etc.
+						styler.ColourTo(i, state);
+						state = SCE_SH_DEFAULT;
+					} else {
+						styler.ColourTo(i - 1, state);
+						state = SCE_SH_DEFAULT;
+						goto restartLexer;
+					}
+				}
+			} else if (state == SCE_SH_STRING
+				|| state == SCE_SH_CHARACTER
+				|| state == SCE_SH_BACKTICKS
+				|| state == SCE_SH_PARAM
+				) {
+				if (!Quote.Down && !isspacechar(ch)) {
+					Quote.Open(ch);
+				} else if (ch == '\\' && Quote.Up != '\\') {
+					i++;
+					ch = chNext;
+					chNext = styler.SafeGetCharAt(i + 1);
+				} else if (ch == Quote.Down) {
+					Quote.Count--;
+					if (Quote.Count == 0) {
+						Quote.Rep--;
+						if (Quote.Rep <= 0) {
+							styler.ColourTo(i, state);
+							state = SCE_SH_DEFAULT;
+							ch = ' ';
+						}
+						if (Quote.Up == Quote.Down) {
+							Quote.Count++;
+						}
+					}
+				} else if (ch == Quote.Up) {
+					Quote.Count++;
+				}
+			}
+		}
+		if (state == SCE_SH_ERROR) {
+			break;
+		}
+		chPrev = ch;
+	}
+	styler.ColourTo(lengthDoc - 1, state);
+}
+
+static bool IsCommentLine(int line, Accessor &styler) {
+	int pos = styler.LineStart(line);
+	int eol_pos = styler.LineStart(line + 1) - 1;
+	for (int i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		if (ch == '#')
+			return true;
+		else if (ch != ' ' && ch != '\t')
+			return false;
+	}
+	return false;
+}
+
+static void FoldBashDoc(unsigned int startPos, int length, int, WordList *[],
+                            Accessor &styler) {
+	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+	unsigned int endPos = startPos + length;
+	int visibleChars = 0;
+	int lineCurrent = styler.GetLine(startPos);
+	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
+	int levelCurrent = levelPrev;
+	char chNext = styler[startPos];
+	int styleNext = styler.StyleAt(startPos);
+	for (unsigned int i = startPos; i < endPos; i++) {
+		char ch = chNext;
+		chNext = styler.SafeGetCharAt(i + 1);
+		int style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+        // Comment folding
+		if (foldComment && atEOL && IsCommentLine(lineCurrent, styler))
+        {
+            if (!IsCommentLine(lineCurrent - 1, styler)
+                && IsCommentLine(lineCurrent + 1, styler))
+                levelCurrent++;
+            else if (IsCommentLine(lineCurrent - 1, styler)
+                     && !IsCommentLine(lineCurrent+1, styler))
+                levelCurrent--;
+        }
+		if (style == SCE_C_OPERATOR) {
+			if (ch == '{') {
+				levelCurrent++;
+			} else if (ch == '}') {
+				levelCurrent--;
+			}
+		}
+		if (atEOL) {
+			int lev = levelPrev;
+			if (visibleChars == 0 && foldCompact)
+				lev |= SC_FOLDLEVELWHITEFLAG;
+			if ((levelCurrent > levelPrev) && (visibleChars > 0))
+				lev |= SC_FOLDLEVELHEADERFLAG;
+			if (lev != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, lev);
+			}
+			lineCurrent++;
+			levelPrev = levelCurrent;
+			visibleChars = 0;
+		}
+		if (!isspacechar(ch))
+			visibleChars++;
+	}
+	// Fill in the real level of the next line, keeping the current flags as they will be filled in later
+	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
+	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
+}
+
+static const char * const bashWordListDesc[] = {
+	"Keywords",
+	0
+};
+
+LexerModule lmOMS(SCLEX_OMS, ColouriseBashDoc, "bash", FoldBashDoc, bashWordListDesc);
diff -Naurp /tmp/sci/LexOthers.cxx scintilla/LexOthers.cxx
--- /tmp/sci/LexOthers.cxx	2008-10-08 13:24:19.000000000 +0200
+++ scintilla/LexOthers.cxx	2008-10-18 15:02:28.000000000 +0200
@@ -652,7 +652,8 @@ static void ColourisePropsLine(
 	while ((i < lengthLine) && isspacechar(lineBuffer[i]))	// Skip initial spaces
 		i++;
 	if (i < lengthLine) {
-		if (lineBuffer[i] == '#' || lineBuffer[i] == '!' || lineBuffer[i] == ';') {
+		if (lineBuffer[i] == '#' || lineBuffer[i] == '!' || lineBuffer[i] == ';' ||
+			(i < (lengthLine - 1) && lineBuffer[i] == '/' && lineBuffer[i+1] == '/')) {
 			styler.ColourTo(endPos, SCE_PROPS_COMMENT);
 		} else if (lineBuffer[i] == '[') {
 			styler.ColourTo(endPos, SCE_PROPS_SECTION);
@@ -663,9 +664,9 @@ static void ColourisePropsLine(
 			styler.ColourTo(endPos, SCE_PROPS_DEFAULT);
 		} else {
 			// Search for the '=' character
-			while ((i < lengthLine) && (lineBuffer[i] != '='))
+			while ((i < lengthLine) && ! (lineBuffer[i] == '=' || isspacechar(lineBuffer[i])))
 				i++;
-			if ((i < lengthLine) && (lineBuffer[i] == '=')) {
+			if ((i < lengthLine) && (lineBuffer[i] == '=' || isspacechar(lineBuffer[i]))) {
 				styler.ColourTo(startLine + i - 1, SCE_PROPS_KEY);
 				styler.ColourTo(startLine + i, SCE_PROPS_ASSIGNMENT);
 				styler.ColourTo(endPos, SCE_PROPS_DEFAULT);
diff -Naurp /tmp/sci/LexPascal.cxx scintilla/LexPascal.cxx
--- /tmp/sci/LexPascal.cxx	2007-06-01 03:57:24.000000000 +0200
+++ scintilla/LexPascal.cxx	2007-06-18 14:11:41.000000000 +0200
@@ -191,7 +191,9 @@ static void ColourisePascalDoc(unsigned
 			}
 		} else if (state == SCE_C_IDENTIFIER) {
 			bool bDoublePoint = ((ch == '.') && (chPrev == '.'));
-			if ((!iswordchar(ch) && ch != '$' && ch != '#' && (ch != '@' || !bInAsm)) || bDoublePoint) {
+			bool bSinglePoint = (ch == '.');
+
+			if ((!iswordchar(ch) && ch != '$' && ch != '#' && (ch != '@' || !bInAsm)) || bDoublePoint || bSinglePoint) {
 				if (bDoublePoint) i--;
 				int lStateChange = classifyWordPascal(styler.GetStartSegment(), i - 1, keywordlists, styler, bInClassDefinition, bInAsm);

diff -Naurp /tmp/sci/scintilla-marshal.c scintilla/scintilla-marshal.c
--- /tmp/sci/scintilla-marshal.c	2004-04-04 12:59:37.000000000 +0200
+++ scintilla/scintilla-marshal.c	2008-06-24 16:28:58.000000000 +0200
@@ -35,8 +35,8 @@
 #define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
 #define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
 #define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
-#define g_marshal_value_peek_enum(v)     (v)->data[0].v_int
-#define g_marshal_value_peek_flags(v)    (v)->data[0].v_uint
+#define g_marshal_value_peek_enum(v)     (v)->data[0].v_long
+#define g_marshal_value_peek_flags(v)    (v)->data[0].v_ulong
 #define g_marshal_value_peek_float(v)    (v)->data[0].v_float
 #define g_marshal_value_peek_double(v)   (v)->data[0].v_double
 #define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
@@ -50,10 +50,10 @@
 /* NONE:INT,POINTER (scintilla-marshal.list:1) */
 void
 scintilla_marshal_VOID__INT_POINTER (GClosure     *closure,
-                                     GValue       *return_value,
+                                     GValue       *return_value G_GNUC_UNUSED,
                                      guint         n_param_values,
                                      const GValue *param_values,
-                                     gpointer      invocation_hint,
+                                     gpointer      invocation_hint G_GNUC_UNUSED,
                                      gpointer      marshal_data)
 {
   typedef void (*GMarshalFunc_VOID__INT_POINTER) (gpointer     data1,
